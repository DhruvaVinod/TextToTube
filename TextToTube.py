import cv2
import easyocr
import json
import numpy as np
import os
import requests
import webbrowser
import yt_dlp
import googleapiclient.discovery
import re
import tempfile
import pygame

from gtts import gTTS
from faster_whisper import WhisperModel
from sentence_transformers import SentenceTransformer
import gradio as gr
import time
from deep_translator import GoogleTranslator, exceptions as dt_exceptions

from PIL import Image, ImageDraw, ImageFont
import subprocess 
import html
from datetime import datetime, timedelta

pygame.mixer.init()

# API Keys
YOUTUBE_API_KEY = "AIzaSyD6hKgUxy-91DW8AnaTrc7nvDHUfWazi_0"
GEMINI_API_KEY = "AIzaSyDDwEucj4KNsnUT4m4qpt1pwnByhm6_vjM"

#Language Code Mapping
LANGUAGE_CODE_MAP = {
    "English": "en",
    "Hindi": "hi",
    "Tamil": "ta",
    "Telugu": "te",
    "Kannada": "kn",
    "Malayalam": "ml",
    "Bengali": "bn",
    "Gujarati": "gu",
    "Marathi": "mr",
    "Punjabi": "pa",
    "Urdu": "ur",
    "Odia": "or",
    "Assamese": "as"
}

# Global variable to store current audio file path
current_audio_path = None

# Global variables for quiz
current_quiz_data = None
user_answers = {}


#cleaning the text generated by gemini
def clean_text(text):
    # Remove Markdown-style headers, bold, bullets, and excess whitespace
    text = re.sub(r"[*#â€¢]+", "", text)  # remove *, #, â€¢
    text = re.sub(r"\n{2,}", "\n", text)  # reduce multiple newlines to one
    text = re.sub(r"\s{2,}", " ", text)  # collapse multiple spaces
    return text.strip()

# Utility Functions
def scan_headline():
    cap = cv2.VideoCapture(0)
    while True:
        ret, frame = cap.read()
        if not ret or frame is None:
            break
        cv2.imwrite("captured_frame.jpg", frame)
        break
    cap.release()
    cv2.destroyAllWindows()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    reader = easyocr.Reader(['en'])
    results = reader.readtext(gray)
    if not results:
        return ""
    return " ".join([res[1] for res in results])

def extract_text_from_image(image_path):
    """Extract text from uploaded image file using OCR"""
    try:
        # Read the image
        image = cv2.imread(image_path)
        if image is None:
            return "âŒ Could not read the image file. Please check the file format."
        
        # Convert to grayscale for better OCR results
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # Initialize EasyOCR reader
        reader = easyocr.Reader(['en'])
        
        # Perform OCR
        results = reader.readtext(gray)
        
        if not results:
            return "âŒ No text found in the image."
        
        # Extract and join all detected text
        extracted_text = " ".join([res[1] for res in results])
        return extracted_text
        
    except Exception as e:
        return f"âŒ Error processing image: {str(e)}"

def get_video(query):
    model = SentenceTransformer("all-MiniLM-L6-v2")
    youtube = googleapiclient.discovery.build("youtube", "v3", developerKey=YOUTUBE_API_KEY)
    search_response = youtube.search().list(q=query, part="snippet", maxResults=10, type="video").execute()

    videos = [{
        "title": item["snippet"]["title"],
        "description": item["snippet"]["description"],
        "url": f"https://www.youtube.com/watch?v={item['id']['videoId']}"
    } for item in search_response.get("items", [])]

    if not videos:
        return None

    query_emb = model.encode(query, convert_to_tensor=True).cpu().numpy()

    similarities = []
    for video in videos:
        title_emb = model.encode(video["title"], convert_to_tensor=True).cpu().numpy()
        desc_emb = model.encode(video["description"], convert_to_tensor=True).cpu().numpy()
        sim = (np.dot(query_emb, title_emb) + np.dot(query_emb, desc_emb)) / (
            np.linalg.norm(query_emb) * (np.linalg.norm(title_emb) + np.linalg.norm(desc_emb))
        )
        similarities.append(sim)

    best_index = np.argmax(similarities)
    return videos[best_index]["title"], videos[best_index]["url"]

def generate_notes_with_gemini(text):
    prompt = f"Generate study notes from the given topic:\n\n{text}"
    data = {"contents": [{"parts": [{"text": prompt}]}]}
    headers = {'Content-Type': 'application/json'}
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
    response = requests.post(url, headers=headers, data=json.dumps(data))
    if response.status_code == 200:
        raw_notes = response.json()["candidates"][0]["content"]["parts"][0]["text"]
        return clean_text(raw_notes)
    else:
        return "âŒ Error generating notes."

def generate_summary_with_gemini(text: str):
        API_KEY = GEMINI_API_KEY
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={API_KEY}"
        prompt = f"Summarize the following text in detail as refernce notes for a student:\n{text}"
        data = {"contents": [{"parts": [{"text": prompt}]}]}
        headers = {'Content-Type': 'application/json'}
        response = requests.post(url, headers=headers, data=json.dumps(data))
        if response.status_code == 200:
            summary = response.json()["candidates"][0]["content"]["parts"][0]["text"]
            return clean_text(summary)
        else:
            return "Error generating summary"

def summarize_video(text):
    result = get_video(text)
    if result is None:
        return "No video found"
    _, video_url = result
    
    # Check for copyright restrictions before processing
    copyright_check = check_video_copyright(video_url)
    if copyright_check["restricted"]:
        return f"âŒ Cannot process this video: {copyright_check['reason']}"
    
    audio_path = download_audio(video_url)
    raw_transcript = transcribe_audio(audio_path)
    
    # Clean up temporary audio file
    if os.path.exists(audio_path):
        os.remove(audio_path)
    
    return generate_summary_with_gemini(raw_transcript)

def check_video_copyright(video_url):
    """Check if video has copyright restrictions"""
    try:
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(video_url, download=False)
            
            # Check various copyright indicators
            title = info.get('title', '').lower()
            description = info.get('description', '').lower()
            uploader = info.get('uploader', '').lower()
            
            # Music industry indicators
            music_keywords = [
                'official music video', 'vevo', 'records', 'entertainment',
                'sony music', 'universal music', 'warner music', 'emi music'
            ]
            
            # Movie/TV indicators
            media_keywords = [
                'official trailer', 'full movie', 'netflix', 'disney',
                'paramount', 'warner bros', 'sony pictures'
            ]
            
            # Check for restricted content
            for keyword in music_keywords + media_keywords:
                if keyword in title or keyword in description or keyword in uploader:
                    return {
                        "restricted": True,
                        "reason": "This appears to be copyrighted content (music/entertainment industry)"
                    }
            
            # Check duration - very long videos might be full movies/shows
            duration = info.get('duration', 0)
            if duration > 7200:  # 2+ hours
                return {
                    "restricted": True,
                    "reason": "Video is too long (likely full movie/show content)"
                }
            
            # Check if video is available
            if info.get('is_live') or not info.get('formats'):
                return {
                    "restricted": True,
                    "reason": "Video is not available for processing"
                }
            
            return {"restricted": False, "reason": None}
            
    except Exception as e:
        return {
            "restricted": True,
            "reason": f"Unable to verify copyright status: {str(e)}"
        }


def download_audio(video_url):
    ffmpeg_path = "C:/ffmpeg/ffmpeg-7.1.1-essentials_build/bin"
    ydl_opts = {
        'ffmpeg_location': ffmpeg_path,
        'format': 'bestaudio/best',
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192'
        }],
        'no_part': True,
        'force_overwrites': True
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(video_url, download=True)
        return ydl.prepare_filename(info).rsplit(".", 1)[0] + ".mp3"

def transcribe_audio(audio_path):
    model = WhisperModel("base", device="cpu", compute_type="int8")
    #model = WhisperModel("base")
    segments, _ = model.transcribe(audio_path)
    return " ".join([segment.text for segment in segments])

def translate_text(text, lang_name, retries=3):
    lang_code = LANGUAGE_CODE_MAP.get(lang_name, "hi")
    max_chunk_size = 5000

    def split_text(text, size):
        return [text[i:i+size] for i in range(0, len(text), size)]

    chunks = split_text(text, max_chunk_size)
    translated = []

    for chunk in chunks:
        for attempt in range(retries):
            try:
                translated_chunk = GoogleTranslator(source="auto", target=lang_code).translate(chunk)
                translated.append(translated_chunk)
                break  # Success
            except dt_exceptions.RequestError:
                if attempt < retries - 1:
                    time.sleep(1)  # wait and retry
                else:
                    return f"âŒ Failed to translate after {retries} attempts. Check your internet connection."
            except Exception as e:
                return f"âŒ Unexpected error: {e}"
    return clean_text("\n".join(translated))

def generate_audio(text, lang_name):
    """Generate audio file and return the file path"""
    global current_audio_path
    
    if not text or not text.strip():
        return None, "âŒ No text provided for audio generation"
    
    lang_code = LANGUAGE_CODE_MAP.get(lang_name, "en")
    
    try:
        # Create a temporary file
        with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as temp_file:
            audio_path = temp_file.name
        
        tts = gTTS(text=text, lang=lang_code)
        tts.save(audio_path)
        current_audio_path = audio_path
        return audio_path, "âœ… Audio generated successfully!"
        
    except Exception as e:
        return None, f"âŒ Audio generation error: {str(e)}"

def play_audio():
    """Play audio with pygame"""
    global current_audio_path
    try:
        if current_audio_path and os.path.exists(current_audio_path):
            if pygame.mixer.music.get_busy():
                pygame.mixer.music.stop()
            pygame.mixer.music.load(current_audio_path)
            pygame.mixer.music.play()
            return "ğŸ”Š Audio playing..."
        else:
            return "âŒ No audio file available to play"
    except Exception as e:
        return f"âŒ Playback error: {str(e)}"

def pause_audio():
    """Pause audio playback"""
    try:
        if pygame.mixer.music.get_busy():
            pygame.mixer.music.pause()
            return "â¸ï¸ Audio paused"
        else:
            return "âŒ No audio currently playing"
    except Exception as e:
        return f"âŒ Pause error: {str(e)}"

def resume_audio():
    """Resume audio playback"""
    try:
        pygame.mixer.music.unpause()
        return "â–¶ï¸ Audio resumed"
    except Exception as e:
        return f"âŒ Resume error: {str(e)}"

def stop_audio():
    """Stop audio playback"""
    try:
        pygame.mixer.music.stop()
        return "â¹ï¸ Audio stopped"
    except Exception as e:
        return f"âŒ Stop error: {str(e)}"

def get_text_for_audio(english_text, translated_text, language):
    """Determine which text to use for audio generation"""
    if language == "English" or not translated_text or translated_text.strip() == "":
        return english_text
    return translated_text

# MODIFIED QUIZ GENERATION FUNCTIONS
def generate_quiz_questions_with_gemini(text, num_questions=10, language="English"):
    """Generate quiz questions using Gemini API in specified language"""
    
    language_prompts = {
        "Hindi": "à¤¹à¤¿à¤‚à¤¦à¥€ à¤®à¥‡à¤‚",
        "Tamil": "à®¤à®®à®¿à®´à®¿à®²à¯",
        "Telugu": "à°¤à±†à°²à±à°—à±à°²à±‹",
        "Kannada": "à²•à²¨à³à²¨à²¡à²¦à²²à³à²²à²¿",
        "Malayalam": "à´®à´²à´¯à´¾à´³à´¤àµà´¤à´¿àµ½",
        "Bengali": "à¦¬à¦¾à¦‚à¦²à¦¾à¦¯à¦¼",
        "Gujarati": "àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚",
        "Marathi": "à¤®à¤°à¤¾à¤ à¥€à¤¤",
        "Punjabi": "à¨ªà©°à¨œà¨¾à¨¬à©€ à¨µà¨¿à©±à¨š",
        "Urdu": "Ø§Ø±Ø¯Ùˆ Ù…ÛŒÚº",
        "Odia": "à¬“à¬¡à¬¼à¬¿à¬†à¬°à­‡",
        "Assamese": "à¦…à¦¸à¦®à§€à¦¯à¦¼à¦¾à¦¤"
    }
    
    lang_instruction = "" if language == "English" else f"Generate all content {language_prompts.get(language, 'in ' + language)}. "
    
    prompt = f"""{lang_instruction}Generate {num_questions} multiple choice questions based on the following topic: {text}

For each question, provide:
1. The question text
2. Four answer options (A, B, C, D)  
3. The correct answer (A, B, C, or D)
4. A brief explanation of why the answer is correct

Format the output as JSON with the following structure:
{{
  "questions": [
    {{
      "question": "Question text here?",
      "options": {{
        "A": "Option A text",
        "B": "Option B text", 
        "C": "Option C text",
        "D": "Option D text"
      }},
      "correct_answer": "A",
      "explanation": "Explanation text here"
    }}
  ]
}}

Make sure the questions are educational and test understanding of the key concepts."""

    data = {"contents": [{"parts": [{"text": prompt}]}]}
    headers = {'Content-Type': 'application/json'}
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
    
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        if response.status_code == 200:
            raw_response = response.json()["candidates"][0]["content"]["parts"][0]["text"]
            
            # Clean the response to extract JSON
            json_start = raw_response.find('{')
            json_end = raw_response.rfind('}') + 1
            
            if json_start != -1 and json_end != -1:
                json_str = raw_response[json_start:json_end]
                quiz_data = json.loads(json_str)
                return quiz_data
            else:
                return {"error": "Failed to parse quiz questions from response"}
        else:
            return {"error": f"API request failed with status {response.status_code}"}
    except json.JSONDecodeError:
        return {"error": "Failed to parse JSON response from Gemini"}
    except Exception as e:
        return {"error": f"Error generating quiz: {str(e)}"}

def generate_quiz_interface(topic, num_questions, language="English"):
    """Generate quiz and return Gradio components"""
    global current_quiz_data, user_answers
    
    if not topic or not topic.strip():
        return [gr.update(visible=False)] * 20  # Hide all quiz components
    
    try:
        num_q = int(num_questions) if num_questions else 10
        quiz_data = generate_quiz_questions_with_gemini(topic, num_q, language)
        
        if "error" in quiz_data:
            return [gr.update(visible=False)] * 20  # Hide all components on error
        
        current_quiz_data = quiz_data
        user_answers = {}
        
        questions = quiz_data.get("questions", [])
        updates = []
        
        # Generate updates for each question component (up to 10 questions)
        for i in range(10):
            if i < len(questions):
                q = questions[i]
                question_text = f"**Question {i+1}:** {q['question']}"
                options = [f"{key}. {value}" for key, value in q['options'].items()]
                
                updates.extend([
                    gr.update(value=question_text, visible=True),
                    gr.update(choices=options, value=None, visible=True)
                ])
            else:
                updates.extend([
                    gr.update(visible=False),
                    gr.update(visible=False)
                ])
        
        return updates
        
    except Exception as e:
        return [gr.update(visible=False)] * 20

def submit_quiz(*answers):
    """Submit quiz and calculate score"""
    global current_quiz_data, user_answers
    
    if not current_quiz_data:
        return "âŒ No quiz data available"
    
    questions = current_quiz_data.get("questions", [])
    score = 0
    total = len(questions)
    results = []
    
    for i, answer in enumerate(answers[:total]):
        if i < len(questions):
            q = questions[i]
            correct_answer = q['correct_answer']
            
            # Extract selected option letter (A, B, C, D)
            selected_option = None
            if answer:
                selected_option = answer[0]  # First character should be the option letter
            
            is_correct = selected_option == correct_answer
            if is_correct:
                score += 1
            
            results.append(f"""
**Question {i+1}:** {q['question']}
**Your Answer:** {answer if answer else 'Not answered'}
**Correct Answer:** {correct_answer}. {q['options'][correct_answer]}
**Explanation:** {q['explanation']}
**Status:** {'âœ… Correct' if is_correct else 'âŒ Incorrect'}
""")
    
    result_text = f"""
# ğŸ¯ Quiz Results

**Score: {score}/{total} ({(score/total)*100:.1f}%)**

---

{''.join(results)}
"""
    
    return result_text

def extract_text_from_pdf(pdf_path):
    """Extract text from uploaded PDF file"""
    try:
        text = ""
        with open(pdf_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            
            for page_num in range(len(pdf_reader.pages)):
                page = pdf_reader.pages[page_num]
                text += page.extract_text() + "\n"
        
        if not text.strip():
            return "âŒ No text found in the PDF file."
        
        return text.strip()
        
    except Exception as e:
        return f"âŒ Error processing PDF: {str(e)}"

def generate_study_plan_with_gemini(topic, duration, daily_hours, language="English"):
    """Generate a personalized study plan using Gemini API with structured output"""
    
    language_prompts = {
        "Hindi": "à¤¹à¤¿à¤‚à¤¦à¥€ à¤®à¥‡à¤‚",
        "Tamil": "à®¤à®®à®¿à®´à®¿à®²à¯",
        "Telugu": "à°¤à±†à°²à±à°—à±à°²à±‹",
        "Kannada": "à²•à²¨à³à²¨à²¡à²¦à²²à³à²²à²¿",
        "Malayalam": "à´®à´²à´¯à´¾à´³à´¤àµà´¤à´¿àµ½",
        "Bengali": "à¦¬à¦¾à¦‚à¦²à¦¾à¦¯à¦¼",
        "Gujarati": "àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚",
        "Marathi": "à¤®à¤°à¤¾à¤ à¥€à¤¤",
        "Punjabi": "à¨ªà©°à¨œà¨¾à¨¬à©€ à¨µà¨¿à©±à¨š",
        "Urdu": "Ø§Ø±Ø¯Ùˆ Ù…ÛŒÚº",
        "Odia": "à¬“à¬¡à¬¼à¬¿à¬†à¬°à­‡",
        "Assamese": "à¦…à¦¸à¦®à§€à¦¯à¦¼à¦¾à¦¤"
    }
    
    lang_instruction = "" if language == "English" else f"Generate all content {language_prompts.get(language, 'in ' + language)}. "
    
    prompt = f"""{lang_instruction}Create a detailed {duration}-day study plan for the topic: "{topic}"

Study Parameters:
- Duration: {duration} days
- Daily study time: {daily_hours} hours per day
- Start date: {datetime.now().strftime('%Y-%m-%d')}

Format the response as structured markdown with clear sections:

# ğŸ“š {duration}-Day Study Plan for {topic}

## ğŸ“Š Plan Overview
- **Topic**: {topic}
- **Duration**: {duration} days
- **Daily Hours**: {daily_hours} hours
- **Total Hours**: {duration * int(daily_hours)} hours
- **Start Date**: {datetime.now().strftime('%B %d, %Y')}
- **End Date**: {(datetime.now() + timedelta(days=int(duration))).strftime('%B %d, %Y')}

## ğŸ¯ Learning Objectives
[List 3-5 main learning objectives]

## ğŸ“… Weekly Breakdown

### Week 1: Foundation Building
[Content for week 1]

### Week 2: Core Concepts
[Content for week 2]

[Continue for all weeks...]

## ğŸ“– Daily Schedule

### Day 1 - {datetime.now().strftime('%B %d')}
**ğŸ¯ Goal**: [Daily objective]
**ğŸ“š Topics**: 
- Topic 1 (30 min)
- Topic 2 (45 min)
- Practice (45 min)

**âœ… Tasks**:
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

---

[Continue for all days with consistent formatting]

## ğŸ”„ Review Schedule
[Include spaced repetition schedule]

## ğŸ“ Assessment Checkpoints
[Include when to test knowledge]

## ğŸ’¡ Study Tips
[Subject-specific study techniques]

## ğŸ“š Recommended Resources
[List of helpful materials]

## ğŸ† Milestones & Rewards
[Achievement markers and motivation]

Use clear headings, bullet points, checkboxes, and emojis for better readability."""

    data = {"contents": [{"parts": [{"text": prompt}]}]}
    headers = {'Content-Type': 'application/json'}
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
    
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        if response.status_code == 200:
            study_plan = response.json()["candidates"][0]["content"]["parts"][0]["text"]
            return clean_text(study_plan)
        else:
            return f"âŒ Error generating study plan. Status code: {response.status_code}"
    except Exception as e:
        return f"âŒ Error generating study plan: {str(e)}"

# 2. ADD this new function for calendar view:

def generate_calendar_view(topic, duration, daily_hours):
    """Generate a visual calendar representation of the study plan"""
    start_date = datetime.now()
    calendar_html = f"""
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 15px; color: white; margin: 10px 0;">
        <h2 style="text-align: center; margin-bottom: 20px;">ğŸ“… Study Calendar for {topic}</h2>
        <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; max-width: 800px; margin: 0 auto;">
    """
    
    # Add day headers
    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    for day in days:
        calendar_html += f'<div style="text-align: center; font-weight: bold; padding: 10px;">{day}</div>'
    
    # Add calendar days
    for i in range(int(duration)):
        current_date = start_date + timedelta(days=i)
        day_num = current_date.day
        is_weekend = current_date.weekday() >= 5
        
        bg_color = "#ff6b6b" if is_weekend else "#4ecdc4"
        calendar_html += f'''
        <div style="background-color: {bg_color}; padding: 15px; border-radius: 10px; text-align: center; min-height: 80px;">
            <div style="font-weight: bold; font-size: 18px;">{day_num}</div>
            <div style="font-size: 12px; margin-top: 5px;">Day {i+1}</div>
            <div style="font-size: 11px; margin-top: 3px;">{daily_hours}h study</div>
        </div>
        '''
    
    calendar_html += "</div></div>"
    return calendar_html

# 3. ADD progress tracking function:

# Global variables for progress tracking
current_progress = {"days_completed": 0, "total_days": 0, "daily_hours": 0}

def create_progress_tracker_components(duration, daily_hours):
    """Create interactive progress tracker components"""
    global current_progress
    current_progress = {"days_completed": 0, "total_days": int(duration), "daily_hours": int(daily_hours)}
    return 0, int(duration), 0, int(daily_hours)

def update_progress(days_completed, total_days, daily_hours):
    """Update progress and return new values"""
    if days_completed > total_days:
        days_completed = total_days
    
    progress_percentage = (days_completed / total_days * 100) if total_days > 0 else 0
    total_hours = days_completed * daily_hours
    
    return (
        days_completed,
        f"{progress_percentage:.1f}%",
        f"{total_hours}h",
        progress_percentage
    )



# 6. MODIFY the button logic to include the new visual components:

def enhanced_generate_study_plan(topic, duration, daily_hours, language):
    """Enhanced study plan generation with visual components"""
    if not topic or not topic.strip():
        return "âŒ Please provide a topic for the study plan.", "", "", gr.update(visible=False), gr.update(visible=False)
    
    try:
        duration_int = int(duration)
        hours_int = int(daily_hours)
        
        if duration_int < 1 or duration_int > 365:
            return "âŒ Duration must be between 1 and 365 days.", "", "", gr.update(visible=False), gr.update(visible=False)
        
        if hours_int < 1 or hours_int > 12:
            return "âŒ Daily hours must be between 1 and 12 hours.", "", "", gr.update(visible=False), gr.update(visible=False)
        
        # Generate the detailed plan
        plan = generate_study_plan_with_gemini(topic, duration_int, hours_int, language)
        
        # Generate calendar view
        calendar = generate_calendar_view(topic, duration_int, hours_int)
        
        # Generate progress tracker
        progress = create_progress_tracker(duration_int)
        
        # Translate if needed
        translated_plan = "" if language == "English" else translate_text(plan, language)
        
        return plan, translated_plan, calendar, progress, gr.update(visible=True), gr.update(visible=True)
        
    except ValueError:
        return "âŒ Please enter valid numbers for duration and daily hours.", "", "", gr.update(visible=False), gr.update(visible=False)


# UI Functions
def ui_scan_headline():
    """Original webcam scanning function"""
    #return scan_headline()
    return "Computer Networks"

def ui_upload_and_extract(uploaded_file):
    """Handle uploaded file and extract text"""
    if uploaded_file is None:
        return "âŒ No file uploaded. Please upload an image file."
    
    try:
        # Get the file path from the uploaded file
        file_path = uploaded_file.name
        
        # Extract text from the uploaded image
        extracted_text = extract_text_from_image(file_path)
        
        return extracted_text
        
    except Exception as e:
        return f"âŒ Error processing uploaded file: {str(e)}"

def ui_watch_video(text):
    result = get_video(text)
    if result is None:
        return "No video found", ""
    title, url = result
    webbrowser.open(url)
    return title, url

def ui_summarize_video(text):
    return summarize_video(text)

def ui_translate_summary(english_text, target_language):
    return translate_text(english_text, target_language)

def ui_generate_audio_summary(english_text, translated_text, language):
    """Generate audio for summary"""
    text_to_speak = get_text_for_audio(english_text, translated_text, language)
    if not text_to_speak:
        return "âŒ No text available to generate audio"
    
    audio_path, message = generate_audio(text_to_speak, language)
    return message

def ui_generate_audio_notes(english_text, translated_text, language):
    """Generate audio for notes"""
    text_to_speak = get_text_for_audio(english_text, translated_text, language)
    if not text_to_speak:
        return "âŒ No text available to generate audio"
    
    audio_path, message = generate_audio(text_to_speak, language)
    return message

def ui_generate_study_plan(topic, duration, daily_hours, language):
    """Generate study plan with validation"""
    if not topic or not topic.strip():
        return "âŒ Please provide a topic for the study plan."
    
    try:
        duration_int = int(duration)
        hours_int = int(daily_hours)
        
        if duration_int < 1 or duration_int > 365:
            return "âŒ Duration must be between 1 and 365 days."
        
        if hours_int < 1 or hours_int > 12:
            return "âŒ Daily hours must be between 1 and 12 hours."
        
        return generate_study_plan_with_gemini(topic, duration_int, hours_int, language)
        
    except ValueError:
        return "âŒ Please enter valid numbers for duration and daily hours."

def ui_generate_audio_study_plan(english_text, translated_text, language):
    """Generate audio for study plan"""
    text_to_speak = get_text_for_audio(english_text, translated_text, language)
    if not text_to_speak:
        return "âŒ No study plan available to generate audio"
    
    # Truncate text if too long for TTS
    max_chars = 5000
    if len(text_to_speak) > max_chars:
        text_to_speak = text_to_speak[:max_chars] + "... (truncated for audio)"
    
    audio_path, message = generate_audio(text_to_speak, language)
    return message

def conditional_translate_summary(text, lang):
    return text if lang == "English" else translate_text(text, lang)

def conditional_translate_notes(text, lang):
    return text if lang == "English" else translate_text(text, lang)

# File saving functions
def save_text_to_file(text, filename):
    if text:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(text)
        return filename
    return None

# Gradio UI
custom_css = """
body {
    background-image: url('webbg.png'); 
    background-size: cover;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
h1 {
    text-align: center; 
    color: #000000; 
    background-color: #FFFDD0; 
    padding: 20px;
    border-radius: 15px;
    font-size: 2.2rem;
}
.gr-button {
    font-size: 16px;
    font-weight: 600;
    background-color: #add8e6 !important;
    color: white !important;
    border: none !important;
    border-radius: 8px !important;
    padding: 10px 20px;
}
.or-divider {
    text-align: center;
    font-size: 18px;
    font-weight: 600;
    color: #666;
    margin: 15px 0;
    position: relative;
}
.or-divider::before,
.or-divider::after {
    content: '';
    position: absolute;
    top: 50%;
    width: 45%;
    height: 1px;
    background-color: #ccc;
}
.or-divider::before {
    left: 0;
}
.or-divider::after {
    right: 0;
}
/* Fixed study plan styling with proper contrast */
.study-plan-container {
    background: #ffffff !important;
    border: 2px solid #e3e6ea;
    border-radius: 15px;
    padding: 20px;
    margin: 10px 0;
    color: #333333 !important;
}

.study-plan-container h1 {
    color: #2c3e50 !important;
    text-align: center;
    border-bottom: 3px solid #3498db;
    padding-bottom: 10px;
}

.study-plan-container h2 {
    color: #2980b9 !important;
    margin-top: 25px;
    margin-bottom: 15px;
}

.study-plan-container h3 {
    color: #16a085 !important;
    margin-top: 20px;
    margin-bottom: 10px;
}

.study-plan-container ul {
    background: #f8f9fa !important;
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
    color: #333333 !important;
}

.study-plan-container li {
    margin-bottom: 8px;
    line-height: 1.6;
    color: #333333 !important;
}

.study-plan-container hr {
    border: none;
    height: 2px;
    background: linear-gradient(90deg, #3498db, #2ecc71);
    margin: 20px 0;
}

.study-plan-container p {
    color: #333333 !important;
    line-height: 1.6;
}
"""


with gr.Blocks(css=custom_css) as demo:
    gr.Markdown("<h1>ğŸ“° Text to Learning Assistant</h1>")

    gr.Markdown("## ğŸ“· Text Input Options")
    
    # Webcam scan button on top
    btn_scan = gr.Button("ğŸ“· Scan with Webcam", variant="primary", size="lg")
    
    # OR divider
    gr.HTML('<div class="or-divider">OR</div>')
    
    # File upload section below
    file_upload = gr.File(
        label="", 
        file_types=["image"], 
        type="filepath",
        show_label=False
    )
    btn_extract = gr.Button("ğŸ” Extract Text from Upload", variant="secondary")
    
    output_text = gr.Textbox(label="ğŸ“„ Extracted Text", interactive=True, lines=3)

    gr.Markdown("## â¡ï¸ What would you like to do?")

    with gr.Accordion("â–¶ï¸ Option 1: Find and Summarize YouTube Video", open=False):
        with gr.Row():
            btn_watch = gr.Button("ğŸ” Find Best Video")
            btn_summary = gr.Button("ğŸ“„ Generate Summary")
        video_title = gr.Textbox(label="ğŸï¸ Video Title", interactive=False)
        video_url = gr.Textbox(label="ğŸ”— Video URL", interactive=False)

        english_summary = gr.Textbox(label="ğŸ“ English Summary", interactive=False)
        language_selector_summary = gr.Dropdown(
            choices=list(LANGUAGE_CODE_MAP.keys()),
            label="ğŸŒ Translate Summary To",
            value="English"
        )
        translated_summary = gr.Textbox(label="ğŸŒ Translated Summary", interactive=False)
        
        # Audio Controls for Summary
        with gr.Row():
            btn_generate_audio_summary = gr.Button("ğŸ”Š Generate Audio")
            btn_play_summary = gr.Button("â–¶ï¸ Play")
            btn_pause_summary = gr.Button("â¸ï¸ Pause")
            btn_resume_summary = gr.Button("ğŸ”„ Resume")
            btn_stop_summary = gr.Button("â¹ï¸ Stop")
        
        audio_status_summary = gr.Textbox(label="ğŸµ Audio Status", interactive=False)

    with gr.Accordion("ğŸ§¾ Option 2: Generate Notes from Extracted Text", open=False):
        with gr.Row():
            btn_notes = gr.Button("ğŸ“˜ Generate Study Notes")
        notes_english = gr.Textbox(label="ğŸ“‘ Notes in English", interactive=False)
        language_selector_notes = gr.Dropdown(
            choices=list(LANGUAGE_CODE_MAP.keys()),
            label="ğŸŒ Translate Notes To",
            value="English"
        )
        notes_translated = gr.Textbox(label="ğŸŒ Translated Notes", interactive=False)
        
        # Audio Controls for Notes
        with gr.Row():
            btn_generate_audio_notes = gr.Button("ğŸ”Š Generate Audio")
            btn_play_notes = gr.Button("â–¶ï¸ Play")
            btn_pause_notes = gr.Button("â¸ï¸ Pause")
            btn_resume_notes = gr.Button("ğŸ”„ Resume")
            btn_stop_notes = gr.Button("â¹ï¸ Stop")
    
        audio_status_notes = gr.Textbox(label="ğŸµ Audio Status", interactive=False)

    # MODIFIED QUIZ SECTION - Interactive Quiz in Gradio
    with gr.Accordion("ğŸ§© Option 3: Interactive Quiz", open=False):
        with gr.Row():
            quiz_language_selector = gr.Dropdown(
                choices=list(LANGUAGE_CODE_MAP.keys()),
                label="ğŸŒ Quiz Language",
                value="English"
            )
            quiz_num_questions = gr.Dropdown(
                choices=["5", "10"],
                label="ğŸ“Š Number of Questions",
                value="5"
            )
            btn_generate_quiz = gr.Button("ğŸ§© Generate Quiz")
        
        # Quiz Questions (up to 10 questions)
        quiz_components = []
        quiz_radios = []
        
        for i in range(10):
            question_md = gr.Markdown(visible=False)
            question_radio = gr.Radio(visible=False, label="Select your answer:")
            quiz_components.extend([question_md, question_radio])
            quiz_radios.append(question_radio)
        
        btn_submit_quiz = gr.Button("ğŸ“ Submit Quiz", visible=False)
        quiz_results = gr.Markdown(visible=False, label="Quiz Results")

    with gr.Accordion("ğŸ“… Option 4: Smart Study Planner", open=False):
        gr.Markdown("### Generate a personalized study plan based on your topic and schedule")
    
        study_duration = gr.Dropdown(
            choices=["7", "14", "21", "30", "60", "90"],
            label="ğŸ“† Study Duration (days)",
            value="14"
        )
        daily_hours = gr.Dropdown(
            choices=["1", "2", "3", "4", "5", "6"],
            label="â° Daily Study Hours",
            value="2"
        )
        study_plan_language = gr.Dropdown(
            choices=list(LANGUAGE_CODE_MAP.keys()),
            label="ğŸŒ Plan Language",
            value="English"
        )
    
        btn_generate_plan = gr.Button("ğŸ“… Generate Study Plan", variant="primary")

        # Enhanced visual components
        # Enhanced visual components
        with gr.Tabs():
            with gr.TabItem("ğŸ“‹ Detailed Plan"):
                study_plan_english = gr.Markdown(label="ğŸ“‹ Study Plan", elem_classes=["study-plan-container"])
                study_plan_translated = gr.Markdown(label="ğŸŒ Translated Study Plan", visible=False, elem_classes=["study-plan-container"])
        
            with gr.TabItem("ğŸ“… Calendar View"):
                calendar_view = gr.HTML(label="ğŸ“… Study Calendar")
        
            with gr.TabItem("ğŸ“ˆ Progress Tracker"):
                gr.Markdown("### ğŸ“ˆ Interactive Study Progress Tracker")
                
                with gr.Row():
                    days_completed_slider = gr.Slider(
                        minimum=0, maximum=100, value=0, step=1,
                        label="ğŸ“… Days Completed",
                        interactive=True
                    )
                    update_progress_btn = gr.Button("ğŸ”„ Update Progress", variant="secondary")
                
                with gr.Row():
                    with gr.Column():
                        days_display = gr.Textbox(label="ğŸ“… Days Progress", interactive=False)
                    with gr.Column():
                        percentage_display = gr.Textbox(label="ğŸ“Š Completion %", interactive=False)
                    with gr.Column():
                        hours_display = gr.Textbox(label="â±ï¸ Total Hours", interactive=False)
                
                progress_bar = gr.HTML("""
                <div style="background: #e9ecef; height: 30px; border-radius: 15px; margin: 20px 0; overflow: hidden;">
                    <div style="background: linear-gradient(90deg, #00c851, #007E33); width: 0%; height: 100%; border-radius: 15px; transition: width 0.5s ease;" id="main-progress-bar"></div>
                </div>
                """)
                
                # Hidden components to store values
                total_days_state = gr.State(value=0)
                daily_hours_state = gr.State(value=0)
    


    # Button Logic
    btn_scan.click(fn=ui_scan_headline, outputs=output_text)
    
    # File upload logic
    btn_extract.click(fn=ui_upload_and_extract, inputs=file_upload, outputs=output_text)

    btn_watch.click(fn=ui_watch_video, inputs=output_text, outputs=[video_title, video_url])
    btn_summary.click(fn=ui_summarize_video, inputs=output_text, outputs=english_summary)

    # Translation logic
    language_selector_summary.change(
        fn=conditional_translate_summary, 
        inputs=[english_summary, language_selector_summary], 
        outputs=translated_summary
    )

    # Summary Audio Controls
    btn_generate_audio_summary.click(
        fn=ui_generate_audio_summary,
        inputs=[english_summary, translated_summary, language_selector_summary],
        outputs=audio_status_summary
    )
    
    btn_play_summary.click(fn=play_audio, outputs=audio_status_summary)
    btn_pause_summary.click(fn=pause_audio, outputs=audio_status_summary)
    btn_resume_summary.click(fn=resume_audio, outputs=audio_status_summary)
    btn_stop_summary.click(fn=stop_audio, outputs=audio_status_summary)

    # Notes generation and translation
    btn_notes.click(fn=generate_notes_with_gemini, inputs=output_text, outputs=notes_english)
    
    language_selector_notes.change(
        fn=conditional_translate_notes, 
        inputs=[notes_english, language_selector_notes], 
        outputs=notes_translated
    )

    # Notes Audio Controls
    btn_generate_audio_notes.click(
        fn=ui_generate_audio_notes,
        inputs=[notes_english, notes_translated, language_selector_notes],
        outputs=audio_status_notes
    )
    
    btn_play_notes.click(fn=play_audio, outputs=audio_status_notes)
    btn_pause_notes.click(fn=pause_audio, outputs=audio_status_notes)
    btn_resume_notes.click(fn=resume_audio, outputs=audio_status_notes)
    btn_stop_notes.click(fn=stop_audio, outputs=audio_status_notes)
    

    # MODIFIED QUIZ BUTTON LOGIC
    def show_quiz_interface_multilingual(topic, num_questions, language):
        updates = generate_quiz_interface(topic, num_questions, language)
        if any(update.get('visible', False) for update in updates if hasattr(update, 'get')):
            updates.extend([gr.update(visible=True), gr.update(visible=False)])
        else:
            updates.extend([gr.update(visible=False), gr.update(visible=False)])
        return updates

    btn_generate_quiz.click(
        fn=show_quiz_interface_multilingual,
        inputs=[output_text, quiz_num_questions, quiz_language_selector],
        outputs=quiz_components + [btn_submit_quiz, quiz_results]
    )

    # Submit quiz logic
    btn_submit_quiz.click(
        fn=lambda *args: [submit_quiz(*args), gr.update(visible=True)],
        inputs=quiz_radios,
        outputs=[quiz_results, quiz_results]
    )
  
    def handle_study_plan_generation(topic, duration, daily_hours, language):
        if not topic or not topic.strip():
            return ("âŒ Please provide a topic for the study plan.", "", "", 
                   gr.update(maximum=1, value=0), "0/1", "0%", "0h", int(duration), int(daily_hours))
    
        try:
            duration_int = int(duration)
            hours_int = int(daily_hours)
        
            # Generate the detailed plan
            plan = generate_study_plan_with_gemini(topic, duration_int, hours_int, language)
        
            # Generate calendar view
            calendar = generate_calendar_view(topic, duration_int, hours_int)
        
            # Translate if needed
            translated_plan = "" if language == "English" else translate_text(plan, language)
        
            return (plan, translated_plan, calendar,
                   gr.update(maximum=duration_int, value=0),
                   f"0/{duration_int}", "0%", "0h",
                   duration_int, hours_int)
        
        except ValueError:
            return ("âŒ Please enter valid numbers for duration and daily hours.", "", "",
                   gr.update(maximum=1, value=0), "0/1", "0%", "0h", 1, 1)

    btn_generate_plan.click(
        fn=handle_study_plan_generation,
        inputs=[output_text, study_duration, daily_hours, study_plan_language],
        outputs=[study_plan_english, study_plan_translated, calendar_view, 
                days_completed_slider, days_display, percentage_display, hours_display,
                total_days_state, daily_hours_state]
    )
    
    # Progress update functionality
    def handle_progress_update(days_completed, total_days, daily_hours):
        days_text, percent_text, hours_text, progress_percent = update_progress(days_completed, total_days, daily_hours)
        
        progress_html = f"""
        <div style="background: #e9ecef; height: 30px; border-radius: 15px; margin: 20px 0; overflow: hidden;">
            <div style="background: linear-gradient(90deg, #00c851, #007E33); width: {progress_percent}%; height: 100%; border-radius: 15px; transition: width 0.5s ease;"></div>
        </div>
        """
        
        return f"{days_completed}/{total_days}", percent_text, hours_text, progress_html
    
    update_progress_btn.click(
        fn=handle_progress_update,
        inputs=[days_completed_slider, total_days_state, daily_hours_state],
        outputs=[days_display, percentage_display, hours_display, progress_bar]
    )

    study_plan_language.change(
        fn=conditional_translate_notes, 
        inputs=[study_plan_english, study_plan_language], 
        outputs=study_plan_translated
    )


    demo.launch(share=True)